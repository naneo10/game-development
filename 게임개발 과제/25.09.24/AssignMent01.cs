
namespace _25._09._24
{
    /*
    [Coroutine 정리]

    참조 사이트
    나무위키 coroutine: https://namu.wiki/w/%EC%BD%94%EB%A3%A8%ED%8B%B4
    유니티 : https://docs.unity3d.com/kr/2021.3/Manual/Coroutines.html
    */
    internal class AssignMent01
    {
        /*
            코루틴(Coroutine)은 비동기 프로그래밍과 동시성(concurrency) 처리를 위한 프로그래밍 구조로,
            함수나 루팅의 실행을 중단(subroutine)과 달리, 실행 흐름을 협력적으로 제어할 수 있으며,
            이를 통해 효율적인 자원 관리와 코드 간결화를 가능하게 합니다.

            [Coroutine의 특징]
            1.중단과 재개: 코루틴은 실행 중간에 특정 키워드를 사용하여 실행을 중단하고 상태를 저장한 뒤,
            나중에 다시 실행을 재개할 수 있다.
            2.비동기 처리: 입출력(I/O) 작업이나 긴 실행 시간을 요구하는 작업에서 비동기적으로 실행되며,
            동시성을 지원한다.
            3.가벼움: 코루틴은 운영체제 스레드와 달리 가벼운 단위로 동작하며,
            하나의 스레드에서 다수의 코루틴을 실행할 수 있다.
            4.상태 유지: 코루틴은 중단된 시점의 상태(변수, 호출 스택)를 유지하며,
            재개 시 이전 상태를 복원하여 실행을 이어간다.

            Coroutine이라는 용어는 co-(함께)와 routine(루틴)의 합성어로, 여러 루틴이 협력(cooperative)
            적으로 실행을 제어하는 프로그래밍 패턴을 의미한다. 이 개념은 1960년대에 멜빈 콘웨이(Melvin Conway)에
            의해 처음 소개되었다. 코루틴은 1960년대에 등장하여 컴퓨터 과학 초기 연구에서 알골리즘 간 협력적
            실행을 구현하기 위해 도입되었다. 이후 다양한 프로그래밍 언어에서 비동기 프로그래밍을 지원하는
            주요 개념으로 채택되었으며, 현대에는 Kotlin, JavaScript, C#, Go 등 여러 언어에서 다양한
            방식으로 구현되고 있다.

            [스레드(Thread)와의 관계]
            코루틴(Coroutine)과 스레드(Thread)는 모두 동시성 프로그래밍을 지원하는 개념이지만,
            서로 다른 동작 방식과 설계 철학을 가지고 있다. 코루틴은 비동기적이고 협력적인 동작을 기반으로 하며,
            스레드는 운영체제에서 제공하는 선점형 동시성을 기반으로 한다. 두 개념은 서로 보완적으로 사용되기도
            하며, 특정 상황에서는 한쪽이 더 적합한 선택이 될 수 있다.
            
        특징               코루틴(Coroutine)                      스레드(Thread)
        제어 방식          협력적 제어(Cooperative Scheduling)     선형적 제어(Preemptive Scheduling)
        실행 단위          애플리케이션 레벨에서 실행 흐름 관리      운영체제 레벨에서 실행 흐름 관리
        컨텍스트 전환 비용  낮음(스택 스위칭 필요 없음)              높음(스택과 레지스터 컨텍스트 전환 필요)
        병렬성             단일 스레드 내에서 동작(병렬 실행 불가능) 다중 코어를 활용하여 병렬 실행 가능
        상태 관리           상태는 애플리케이션 코드에서 관리        상태는 운영체제가 관리
        수량               한 스레드에서 수천 개의 코루틴 실행 가능  스레드 수는 운영체제 및 하드웨어 자원에 제한됨
        오버해드            적음(가벼움)                            높음(스레드 스택, 스케줄링 비용)

        코루틴과 스레드는 서로 대체되는 개념이라기보다는, 상호 보완적으로 사용될 수 있다.
        
            1.스레드 위의 코루틴
            -대부분의 코루ㅌ니 프레임워크(예:Kotlin, Python)는 코루틴이 스레드 위에서 실행되도록 설계되어 있다.
            -하나의 스레드에서 다수의 코루틴을 실행할 수 있으며, 코루틴의 비동기적 특성 덕분에 스레드 수를 줄이고
            자원 사용을 최적화할 수 있다.
            2.병렬성과 동시성의 결함
            -스레드는 **병렬성(parallelism)**을 구현하는 데 적합하고, 코루틴은 **동시성(concurrency)**을
            구현하는 데 적합하다.
            -예를 들어, 코어가 4개인 시스템에서 4개의 스레드가 병렬로 실행되면서, 각 스레드 내에서 코루틴이
            동시성을 처리하는 방식으로 결합할 수 있다.

            코루틴(coroutine)은 스레드(thread)를 완전히 대체하지 못한다. 두 개념은 서로 다른 문제를 해결하기 위해
            설계되었기 때문에, 각각의 강점과 약점을 가진다. 일반적으로 I/O중심 작업이나 대기 시간이 많은 작업은
            코루틴이 더 적합하며, CPU 중심 작업이나 병렬 처리는 스레드가 더 적합하다.

            코루틴과 스레드는 동시성과 병렬성의 두 축을 담당하며, 각기 다른 요구사항에 적합한 솔루션을 제공한다.
            코루틴은 비동기와 가벼운 실행을, 스레드는 병렬성과 하드웨어 활용을 중점적으로 지원한다.
            현대 프로그래밍에서는 두 개념을 상호 보완적으로 활용하여 높은 성능과 효율성을 달성할 수 있다.

        ==============================================================================================
        [Unity]
        코루틴(coroutine)을 사용하면 작업을 다수의 프레임에 분산할 수 있습니다. Unity에서 코루틴은 실행을
        일시 정지하고 제어를 Unity에 반환하지만 중단한 부분에서 다음 프레임을 계속할 수 있는 메서드 입니다.

        대부분의 경우 메서드를 호출하면 실행을 완료한 뒤 호출한 메서드에 제어와 선택적 반환 값을 반환합니다.
        즉, 메서드 내에서 발생한 모든 행동은 단일 프레임 업데이트 내에서 발생해야 합니다.

        시간의 흐름에 따른 이벤트의 시퀀스나 절차상의 애니메이션을 포함하기 위해 메서드 콜을 사용하고자
        하는 상황에서 코루틴을 사용할 수 있습니다.

        하지만 코루틴은 스레드가 아니라는 점을 명심해야 합니다. 코루틴의 동기 작업은 여전히 메인스레드에서
        실행됩니다. 메인 스레드에 소요되는 CPU 시간을 줄이려면 다른 스크립트 코드에서와 마찬가지로 코루틴의
        작업 차단을 방지하는 것이 중요합니다.

        코루틴은 HTTP전송, 에셋 로드, 파일 I/O 완료 등을 기다리는 것과 같이 긴 비동기 작업을 처리해야
        하는 경우 코루틴을 사용하는 것이 가장 좋습니다.

        -코루틴은 IEumerator 반환 타입과 바디 어딘가에 포함되 yield 반환문으로 선언하는 메서드입니다.
        'yield return null' 라인은 실행이 일시 정지되고 다음 프레임에서 다시 시작되는 지점입니다.
        코루틴 실행을 설정하려면 'StartCoroutine' 함수를 사용해야 합니다.

        [코루틴 시간 지연]
        yield문 다음에 프레임에 코루틴을 다시 시작합니다.

        [코루틴 정지]
        -'StopCoroutine'과 'StopAllCoroutine'을 사용하여 코루틴을 정지할 수 있습니다.
        -코루틴에 연결된 오브젝트를 비활성화하기 위해 'SetActive'를 'false'로 설정하면 코루틴이 정지됩니다.
        -'Destroy'을 즉시 트리거하며 Unity는 코루틴을 처리하여 효과적으로 정지시킵니다.
        -마지막으로 'OnDestroy'는 프레임 끝에서 호출됩니다.

        [코루틴 분석]
        코루틴은 다른 스크립트 코드와 다르게 실행됩니다. 대부분의 Unity 스크립트 코드는 단일 위치의
        성능 트레이스 내, 특정 콜백 호출 아래에 나타납니다. 반면, 코루틴의 CPU코드는 항상 트레이스의 두 곳에서
        나타납니다.

        코루틴의 모든 시작 코드(코루틴 메서드의 시작부터 첫 번째 yield문 까지)는 Unity가 코루틴을 시작할 때마다
        트레이스에 나타납니다. 시작 코드는 StartCoroutine 메서드가 호출될 때마다 종종 나타납니다. Unity 콜백(
        IEnumerator를 반환하는 Start 콜백 등)에서 생성된 코루틴은 각 Unity 콜백에서 최초로 나타납니다.

        코루틴의 나머지 코드(즉 다시 시작하는 시점에서부터 실행이 종료될 때까지의 코드)는 Unity메인 루프에 있는
        DelayedCallManager 라인에서 나타나게 됩니다.

        이는 Unity가 코루틴을 실행하는 방법 때문에 발생합니다. 'C# 컴파일러'는 코루틴을 지원하는
        클래스 인스턴스를 자동으로 생성합니다. 그런 다음 Unity는 이 오브젝트를 사용하여 단일 메서드를 여러 번
        호출하는 동안 코루틴의 상태를 추적합니다. 코루틴에서 로컬 범위 변수가 yield 호출이 진행되는 동안
        유지되어야 하기 때문에 Unity는 로컬 범위 변수를 생성된 크래스로 옮깁니다. 이렇게 하면 코루틴이
        작동되는 동안 힙에 할당된 상태로 남아있습니다. 이 오브젝트는 또한 코루틴의 내부 상태를 추적하여
        yield 호출 이후에 코루틴이 코드의 어느 부분부터 다시 시작해야 하는지를 기억합니다.

        그렇기 때문에 코루틴을 시작할 때 메모리 사용량은 고정된 오버헤드 할당에 로컬 범위 변수의
        크기를 합한 양과 동일합니다.

        코루틴을 시작하는 코드는 오브젝트를 생성하고 호출하며 그 이후 Unity의 'DelayedCallManager'가 코루틴의
        yield 조건이 만족될 때마다 다시 오브젝트를 호출합니다. 코루틴은 보통 다른 코루틴의 외부에서 시작하기
        때문에 이는 yield 호출과 'DelayedCallManager'사이에서 실행 오버헤드를 나눕니다.

        Unity 프로파일러를 사용하여 애플리케이션에서 코루틴을 실행하는 부분을 검사하고 이해할 수 있습니다.
        이렇게 하려면 모든 스크립트 코드를 프로파일링하고 모든 함수 호출을 기록하는 세부 프로파일링을 활성화하여
        애플리케이션을 프로파일링합니다. 그런 다음 'CPU 사용 프로파일러 모듈'을 사용하여 애플리케이션의
        코루틴을 조사할 수 있습니다.
        
        일련의 작업을 최대한 적은 수의 개별 코루틴으로 압축하는 것이 가장 좋습니다. 중첩 코루틴은 코드 명료성과
        유지관리에 용이하지만 코루틴이 오브젝트를 추적하기 때문에 더 많은 메모리가 소모됩니다.

        코루틴이 매 프레임마다 실행되고 오래 실행되는 작업에서 yield 되지 않는 경우 Update 또는 LateUpdate
        콜백으로 대체하는 것이 더 효과적입니다. 이는 오래 실행되거나 무한 루프되는 코루틴의 경우에 유용합니다.

        */
    }
}
